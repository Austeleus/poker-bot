"""
Exploitability calculator for poker strategies.

This module implements best response calculation to measure how exploitable
a given strategy is, expressed in milli-big-blinds per hand (mbb/hand).
"""

import numpy as np
import random
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass

from core.holdem_info_set import HoldemInfoSet, Street, BettingRound, HoldemAction
from core.card_utils import generate_all_preflop_hands, calculate_preflop_equity


@dataclass
class GameOutcome:
    """Represents the outcome of a poker hand."""
    player_0_utility: float  # Utility from Player 0's perspective
    player_1_utility: float  # Utility from Player 1's perspective
    
    
class ExploitabilityCalculator:
    """
    Calculate exploitability using best response analysis.
    
    This implements a simplified but principled approach:
    1. For each player, compute their expected utility against opponent's strategy
    2. Compute best response strategy against the opponent  
    3. Calculate utility gain from switching to best response
    4. Express as milli-big-blinds per hand
    """
    
    def __init__(self, trainer, num_samples: int = 1000):
        """
        Initialize exploitability calculator.
        
        Args:
            trainer: Trained MCCFR trainer with strategy profile
            num_samples: Number of hands to sample for evaluation
        """
        self.trainer = trainer
        self.num_samples = num_samples
        self.preflop_hands = generate_all_preflop_hands()
        
    def calculate_exploitability(self) -> Dict[str, float]:
        """
        Calculate exploitability for both players.
        
        Returns:
            Dictionary with exploitability metrics in mbb/hand
        """
        print(f"🔍 Calculating exploitability with {self.num_samples} hand samples...")
        
        # Calculate exploitability for each player
        exploitability_p0 = self._calculate_player_exploitability(0)
        exploitability_p1 = self._calculate_player_exploitability(1)
        
        # Overall exploitability is the sum (how much both players can be exploited)
        total_exploitability = exploitability_p0 + exploitability_p1
        
        return {
            'player_0_exploitability_mbb': exploitability_p0,
            'player_1_exploitability_mbb': exploitability_p1, 
            'total_exploitability_mbb': total_exploitability,
            'average_exploitability_mbb': total_exploitability / 2,
            'samples_used': self.num_samples
        }
    
    def _calculate_player_exploitability(self, player: int) -> float:
        """
        Calculate how much a specific player can be exploited.
        
        Args:
            player: Player index (0 or 1)
            
        Returns:
            Exploitability in mbb/hand
        """
        opponent = 1 - player
        
        # Sample random hands and calculate utilities
        current_utility = 0.0
        best_response_utility = 0.0
        
        for _ in range(self.num_samples):
            # Sample random hole cards for both players
            sampled_hands = random.sample(self.preflop_hands, 2)
            player_cards = sampled_hands[0]
            opponent_cards = sampled_hands[1]
            
            # Randomly assign positions (SB/BB) - matching our symmetric training
            if random.random() < 0.5:
                player_position = 0  # SB
                opponent_position = 1  # BB
                player_stack = 199
                opponent_stack = 198
                current_bet = 2  # Player faces BB
            else:
                player_position = 1  # BB  
                opponent_position = 0  # SB
                player_stack = 198
                opponent_stack = 199
                current_bet = 0 if player_position == 1 else 2  # BB can check
            
            # Calculate utility under current strategies
            current_util = self._simulate_hand_outcome(
                player, player_cards, opponent_cards,
                player_position, opponent_position,
                player_stack, opponent_stack, current_bet,
                use_best_response=False
            )
            current_utility += current_util
            
            # Calculate utility under best response for this player
            best_util = self._simulate_hand_outcome(
                player, player_cards, opponent_cards,
                player_position, opponent_position,
                player_stack, opponent_stack, current_bet,
                use_best_response=True
            )
            best_response_utility += best_util
        
        # Average utilities
        avg_current = current_utility / self.num_samples
        avg_best_response = best_response_utility / self.num_samples
        
        # Exploitability = gain from switching to best response
        exploitability = avg_best_response - avg_current
        
        # Convert to milli-big-blinds per hand
        # 1 big blind = 2 chips, so 1 mbb = 0.002 chips
        exploitability_mbb = exploitability * 1000 / 2  # Convert chips to mbb
        
        return max(0.0, exploitability_mbb)  # Exploitability can't be negative
    
    def _simulate_hand_outcome(self, player: int, player_cards: Tuple[int, int],
                              opponent_cards: Tuple[int, int], player_position: int,
                              opponent_position: int, player_stack: int, 
                              opponent_stack: int, current_bet: int,
                              use_best_response: bool = False) -> float:
        """
        Simulate a single hand outcome.
        
        Args:
            player: Player whose utility we're calculating
            player_cards: Player's hole cards
            opponent_cards: Opponent's hole cards  
            player_position: Player's position (0=SB, 1=BB)
            opponent_position: Opponent's position
            player_stack: Player's remaining stack
            opponent_stack: Opponent's remaining stack
            current_bet: Current bet amount
            use_best_response: If True, use best response for player
            
        Returns:
            Utility for the player from this hand
        """
        # Create information set for the player
        stack_sizes = [0, 0]
        stack_sizes[player] = player_stack
        stack_sizes[1 - player] = opponent_stack
        
        info_set = HoldemInfoSet(
            player=player,
            hole_cards=player_cards,
            community_cards=(),
            street=Street.PREFLOP,
            betting_history=[],
            position=player_position,
            stack_sizes=tuple(stack_sizes),
            pot_size=3,  # SB + BB
            current_bet=current_bet,
            small_blind=1,
            big_blind=2
        )
        
        # Get player's strategy (current or best response)
        if use_best_response and player_position == 0:  # Only use best response when player acts first
            # Simplified best response: choose action with highest expected value
            player_strategy = self._get_best_response_strategy(info_set, opponent_cards)
        else:
            # Use current learned strategy
            player_strategy = self.trainer.strategy_profile.get_average_strategy(player, info_set)
        
        # Sample action from strategy
        legal_actions = info_set.get_legal_actions()
        legal_probs = player_strategy[legal_actions]
        if np.sum(legal_probs) > 0:
            legal_probs = legal_probs / np.sum(legal_probs)
            action = np.random.choice(legal_actions, p=legal_probs)
        else:
            action = np.random.choice(legal_actions)
        
        # Simulate outcome based on action
        return self._evaluate_action_outcome(
            player, action, player_cards, opponent_cards,
            player_position, player_stack, opponent_stack
        )
    
    def _get_best_response_strategy(self, info_set: HoldemInfoSet, 
                                   opponent_cards: Tuple[int, int]) -> np.ndarray:
        """
        Calculate best response strategy for this information set.
        
        This is a simplified greedy best response that evaluates each action
        against the known opponent cards (perfect information for calculation).
        """
        legal_actions = info_set.get_legal_actions()
        action_values = np.zeros(6)  # 6 possible actions
        
        for action in legal_actions:
            # Estimate value of this action against opponent
            action_values[action] = self._estimate_action_value(
                info_set, action, opponent_cards
            )
        
        # Create strategy that puts all probability on best action
        best_action = legal_actions[np.argmax(action_values[legal_actions])]
        strategy = np.zeros(6)
        strategy[best_action] = 1.0
        
        return strategy
    
    def _estimate_action_value(self, info_set: HoldemInfoSet, action: int,
                              opponent_cards: Tuple[int, int]) -> float:
        """Estimate the value of an action against opponent cards."""
        player_cards = info_set.hole_cards
        
        if action == HoldemAction.FOLD:
            # Folding: lose what we've invested
            if info_set.position == 0:  # SB
                return -1  # Lose small blind
            else:  # BB
                return -2 if info_set.current_bet > 0 else 0
                
        elif action == HoldemAction.CHECK_CALL:
            # Calling/checking: go to showdown
            try:
                equity = calculate_preflop_equity(player_cards, opponent_cards, num_simulations=50)
                pot_size = info_set.pot_size + info_set.current_bet
                return equity * pot_size - info_set.current_bet * (1 - equity)
            except:
                return 0.0  # Fallback
                
        else:
            # Raising: simplified model - fold out weak hands, get called by strong hands
            try:
                equity = calculate_preflop_equity(player_cards, opponent_cards, num_simulations=50)
                
                # Estimate fold probability based on opponent hand strength
                from core.card_utils import get_preflop_hand_strength
                opponent_strength = get_preflop_hand_strength(opponent_cards)
                
                # Stronger opponent hands are less likely to fold
                fold_prob = max(0.1, 1.0 - opponent_strength)
                
                # Value = (fold_prob * pot) + ((1-fold_prob) * showdown_value)
                pot_win = info_set.pot_size
                showdown_value = equity * (info_set.pot_size * 2) - info_set.pot_size * (1 - equity)
                
                return fold_prob * pot_win + (1 - fold_prob) * showdown_value
            except:
                return 0.0
    
    def _evaluate_action_outcome(self, player: int, action: int,
                                player_cards: Tuple[int, int], opponent_cards: Tuple[int, int],
                                player_position: int, player_stack: int, 
                                opponent_stack: int) -> float:
        """
        Evaluate the outcome of an action in a simplified game model.
        
        This is a simplified evaluation for exploitability calculation.
        """
        if action == HoldemAction.FOLD:
            # Player folds: loses invested amount
            if player_position == 0:  # SB
                return -1.0  # Lose small blind
            else:  # BB
                return -2.0  # Lose big blind (if there was a raise)
                
        else:
            # Goes to showdown: use preflop equity
            try:
                equity = calculate_preflop_equity(player_cards, opponent_cards, num_simulations=50)
                
                # Simplified pot calculation
                pot_size = 4  # Assume both players put in 2 chips
                
                # Expected value based on equity
                return equity * pot_size - 2.0  # Subtract our investment
            except:
                return 0.0  # Fallback if equity calculation fails


def test_exploitability_calculator():
    """Test the exploitability calculator."""
    print("🧪 Testing Exploitability Calculator")
    print("=" * 40)
    
    # This would need a trained model to test properly
    print("Note: Full testing requires a trained MCCFR model")
    print("The calculator is ready to use with: ExploitabilityCalculator(trainer)")


if __name__ == "__main__":
    test_exploitability_calculator()